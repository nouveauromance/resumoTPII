!! IntroduÃ§Ã£o a PadrÃµes de Projeto

ğŸ§  O que sÃ£o padrÃµes de projeto?
. SÃ£o soluÃ§Ãµes reutilizÃ¡veis para problemas comuns no desenvolvimento de software orientado a objetos.
. NÃ£o sÃ£o cÃ³digo pronto, e sim modelos/conceitos que guiam a estrutura do seu cÃ³digo.
. Eles ajudam a deixar o sistema mais flexÃ­vel, reutilizÃ¡vel, organizado e fÃ¡cil de manter.

ğŸ“š Origem:
. Inspirados em arquitetura (Christopher Alexander).
. Aplicados a software pelos â€œGang of Fourâ€ (GoF): Gamma, Helm, Johnson e Vlissides.
. Documentados no livro â€œDesign Patterns: Elements of Reusable Object-Oriented Softwareâ€ (1995).

ğŸ§© PadrÃµes de Projeto â‰  Algoritmos:
. Um algoritmo Ã© uma sequÃªncia de passos.
. Um padrÃ£o Ã© uma estrutura mais genÃ©rica para organizar soluÃ§Ãµes.

ğŸ¯ BenefÃ­cios:
. ReutilizaÃ§Ã£o de soluÃ§Ãµes jÃ¡ testadas.
. Facilitam a comunicaÃ§Ã£o entre desenvolvedores.
. Melhoram a manutenÃ§Ã£o, documentaÃ§Ã£o e qualidade do cÃ³digo.
. Evitam reinventar.

ğŸ§± Cada padrÃ£o tem 4 elementos essenciais:
. Nome â€“ Facilita a comunicaÃ§Ã£o.
. Problema â€“ Quando e por que usar o padrÃ£o.
. SoluÃ§Ã£o â€“ Como ele resolve o problema.
. ConsequÃªncias â€“ Pontos positivos e negativos.

ğŸš¨ Cuidados:
. NÃ£o tente usar padrÃ£o sÃ³ por usar.
. Nem todo problema precisa de um padrÃ£o complexo. Ã€s vezes, cÃ³digo simples Ã© o ideal.

!! Factory Method 

ğŸ¯ O que Ã© o Factory Method?
. Ã‰ um padrÃ£o criacional que define uma interface para criar objetos, mas permite que subclasses decidam qual classe instanciar.
. Em vez de usar new direto no cÃ³digo, vocÃª chama um mÃ©todo fÃ¡brica (create() ou factoryMethod()) e decide qual objeto retornar.

ğŸ’¬ Analogia:
Imagina uma fÃ¡brica de transporte. VocÃª pede um â€œmeio de transporteâ€ e ela pode te entregar um caminhÃ£o ou um navio, 
dependendo da subclasse. VocÃª sÃ³ fala: â€œme dÃ¡ um transporteâ€, sem se preocupar com o que vem.

ğŸ“¦ Quando usar?
. Quando vocÃª nÃ£o sabe de antemÃ£o qual classe de objeto serÃ¡ necessÃ¡ria.
. Quando vocÃª quer desacoplar o cÃ³digo do cliente da lÃ³gica de criaÃ§Ã£o.
. Quando o sistema precisa ser extensÃ­vel com novos tipos de produtos.

ğŸ§± Estrutura:
. Produto (interface) â€“ ex: Transporte
. Produtos concretos â€“ CaminhÃ£o, Navio
. Criador (classe base) â€“ define o mÃ©todo fÃ¡brica.
. Criadores concretos â€“ cada um retorna um produto especÃ­fico.

interface Transporte {
    void entregar();
}

class Caminhao implements Transporte {
    public void entregar() {
        System.out.println("Entrega por terra.");
    }
}

class Navio implements Transporte {
    public void entregar() {
        System.out.println("Entrega por mar.");
    }
}

abstract class Logistica {
    public abstract Transporte criarTransporte();
}

class LogisticaRodoviaria extends Logistica {
    public Transporte criarTransporte() {
        return new Caminhao();
    }
}

class LogisticaMaritima extends Logistica {
    public Transporte criarTransporte() {
        return new Navio();
    }
}

âœ… Vantagens:
. PrincÃ­pio Aberto/Fechado: pode adicionar novos tipos de produtos sem alterar o cÃ³digo existente.
. Responsabilidade Ãºnica: separa a lÃ³gica de criaÃ§Ã£o da lÃ³gica de uso.
. Diminui o acoplamento com classes concretas.

âš ï¸ Desvantagens:
. Introduz muito mais classes e interfaces no projeto.
. Pode parecer complexo em casos mais simples.

!! Abstract Factory

ğŸ¯ O que Ã©?
. Ã‰ um padrÃ£o criacional que cria famÃ­lias de objetos relacionados entre si sem depender das classes concretas.
. Ao invÃ©s de instanciar diretamente (new), vocÃª chama uma fÃ¡brica abstrata que fornece os objetos corretos de acordo com o â€œtemaâ€.

ğŸ’¬ Analogia:
Imagina que vocÃª tÃ¡ montando um tema de RPG.
VocÃª pode escolher o â€œtema Heroicoâ€ ou â€œtema Malignoâ€, e cada um vem com seu Guerreiro, Mago e Arma prÃ³prios.
VocÃª sÃ³ diz: "quero o tema Heroico" â€” e a fÃ¡brica jÃ¡ te dÃ¡ o combo certo ğŸ›¡ï¸âœ¨

ğŸ“¦ Quando usar?
. Quando precisa criar vÃ¡rios objetos que dependem uns dos outros (famÃ­lias).
. Quando quer garantir que todos os objetos criados sÃ£o compatÃ­veis entre si.
. Ideal pra interfaces grÃ¡ficas multiplataforma, RPGs, jogos, e-commerce, etc.

ğŸ§± Estrutura:
// Interfaces dos produtos
interface Guerreiro {
    void atacar();
}
interface Mago {
    void lanÃ§arMagia();
}

// ImplementaÃ§Ãµes heroicas
class GuerreiroHeroico implements Guerreiro { ... }
class MagoHeroico implements Mago { ... }

// ImplementaÃ§Ãµes malignas
class GuerreiroMalvado implements Guerreiro { ... }
class MagoMalvado implements Mago { ... }

// FÃ¡brica abstrata
interface FabricaPersonagem {
    Guerreiro criarGuerreiro();
    Mago criarMago();
}

// FÃ¡bricas concretas
class FabricaHeroica implements FabricaPersonagem { ... }
class FabricaMaligna implements FabricaPersonagem { ... }

âœ… Vantagens:
. Garante consistÃªncia entre objetos relacionados.
. Baixo acoplamento com as classes concretas.
. Facilita a escalabilidade do sistema.

âš ï¸ Desvantagens:
. Adiciona complexidade com muitas interfaces e classes.
. Se precisar de novos produtos, a fÃ¡brica tambÃ©m precisa ser alterada.

!! Builder

ğŸ¯ O que Ã©?
. O Builder Ã© um padrÃ£o criacional que permite criar objetos complexos passo a passo.
. Ele separa a construÃ§Ã£o de um objeto da sua representaÃ§Ã£o final.

ğŸ’¬ Analogia:
Pensa numa pizzaria ğŸ•.
VocÃª tem uma classe PizzaBuilder que monta a pizza do seu jeito: primeiro a massa, depois o molho, aÃ­ o queijo, os toppingsâ€¦
No final, vocÃª chama build() e recebe sua pizza perfeita. VocÃª monta do seu jeito, sem precisar criar tudo de uma vez num construtor gigante.

ğŸ“¦ Quando usar?
. Quando a criaÃ§Ã£o de um objeto exige vÃ¡rios passos ou configuraÃ§Ãµes.
. Quando vocÃª quer evitar construtores enormes com mil parÃ¢metros.
. Quando vocÃª precisa de diferentes representaÃ§Ãµes para o mesmo objeto (ex: carro esportivo vs SUV).

ğŸ§± Estrutura:
// Produto final
class Carro {
    String motor;
    String cor;
    int portas;
}

// Builder
interface CarroBuilder {
    void construirMotor();
    void construirCor();
    void construirPortas();
    Carro getResultado();
}

// Builder concreto
class CarroEsportivoBuilder implements CarroBuilder { ... }
class SUVBuilder implements CarroBuilder { ... }

// Diretor (opcional)
class Concessionaria {
    public void construirCarro(CarroBuilder builder) {
        builder.construirMotor();
        builder.construirCor();
        builder.construirPortas();
    }
}

âœ… Vantagens:
. CÃ³digo de criaÃ§Ã£o modular e reutilizÃ¡vel.
. FÃ¡cil de adicionar ou remover partes do objeto.
. Ideal pra criar objetos imutÃ¡veis e com muitos atributos opcionais.

âš ï¸ Desvantagens:
. Pode ficar verboso (muitas classes/interfaces).
. Ã€s vezes Ã© overkill pra objetos simples.

Esse padrÃ£o Ã© Ã³timo quando o objeto tem muitas â€œpecinhasâ€ opcionais. E o mais legal Ã© que vocÃª pode usar o mesmo processo de construÃ§Ã£o para diferentes tipos de resultados ğŸ˜

!! Prototype 

ğŸ¯ O que Ã©?
. O Prototype Ã© um padrÃ£o criacional que permite criar novos objetos clonando objetos existentes.
. VocÃª cria um modelo (protÃ³tipo) e copia ele sempre que quiser um novo objeto parecido, mas com pequenas diferenÃ§as.

ğŸ’¬ Analogia:
Pensa num cardÃ¡pio de pizzaria.
VocÃª tem uma pizza padrÃ£o â€œCalabresaâ€ no cardÃ¡pio. Quando o cliente pede, vocÃª clona aquela base e sÃ³ muda o que ele quiser (sem cebola, borda recheada, etc).
VocÃª nÃ£o precisa recriar a pizza do zero.

ğŸ“¦ Quando usar?
. Quando vocÃª quer evitar o new e reaproveitar configuraÃ§Ãµes complexas de objetos.
. Quando objetos tÃªm muitas propriedades e seriam difÃ­ceis de inicializar do zero.
. Quando vocÃª quer independÃªncia da classe concreta.

ğŸ§± Estrutura:
interface Clonavel {
    Clonavel clone();
}

class Pessoa implements Clonavel {
    String nome;
    int idade;

    public Pessoa(String nome, int idade) {
        this.nome = nome;
        this.idade = idade;
    }

    public Clonavel clone() {
        return new Pessoa(this.nome, this.idade);
    }
}
java
Copiar
Editar
Pessoa original = new Pessoa("Nat", 18);
Pessoa copia = (Pessoa) original.clone();
copia.nome = "nouveauromance";

âœ… Vantagens:
. Evita recriar objetos complexos manualmente.
. Funciona independente da linguagem (quase toda linguagem tem algo como .clone() ou cÃ³pia).
. Permite criar novas variaÃ§Ãµes com facilidade.

âš ï¸ Desvantagens:
. Clonagem pode ser complicada quando o objeto tem referÃªncias para outros objetos (profundidade da cÃ³pia: shallow x deep copy).
. Precisa definir claramente o que significa â€œclonarâ€ para cada objeto.
. Esse padrÃ£o combina muito com sistemas onde vocÃª precisa gerar variaÃ§Ãµes rÃ¡pidas de um objeto-base, tipo RPGs, pedidos de e-commerce, editores grÃ¡ficos, etc.

!! Singleton

ğŸ¯ O que Ã©?
. O Singleton garante que sÃ³ exista uma Ãºnica instÃ¢ncia de uma classe e fornece um ponto global de acesso a ela.
. Serve pra representar coisas Ãºnicas no sistema, como uma conexÃ£o com banco de dados, configuraÃ§Ãµes globais, logs, etc.

ğŸ’¬ Analogia:
Imagina que seu sistema tem um sÃ³ â€œpresidenteâ€. NÃ£o pode ter dois ao mesmo tempo, nÃ©?
EntÃ£o o Singleton diz: "sÃ³ pode me instanciar uma vez, e todo mundo vai usar essa mesma instÃ¢ncia."

ğŸ“¦ Quando usar?
. Quando sÃ³ pode haver um objeto controlando uma coisa.
. Quando vÃ¡rios lugares no sistema precisam acessar o mesmo recurso compartilhado.

ğŸ§± Estrutura:
public class Presidente {
    private static Presidente instancia;

    private Presidente() {
        // construtor privado pra impedir que criem novas instÃ¢ncias
    }

    public static Presidente getInstancia() {
        if (instancia == null) {
            instancia = new Presidente();
        }
        return instancia;
    }
}
java
Copiar
Editar
Presidente p1 = Presidente.getInstancia();
Presidente p2 = Presidente.getInstancia();

System.out.println(p1 == p2); // true (mesma instÃ¢ncia)

âœ… Vantagens:
. Garante unicidade de instÃ¢ncia.
. Fornece um ponto central de acesso ao objeto.
. Reduz uso de memÃ³ria quando usado corretamente.

âš ï¸ Desvantagens:
. Pode violar o princÃ­pio da responsabilidade Ãºnica.
. Dificulta testes unitÃ¡rios (por causa do estado global).
. Pode ser abusado e virar uma â€œgambiarra globalâ€ se usado Ã  toa.
